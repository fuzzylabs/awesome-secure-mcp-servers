#!/usr/bin/env python3
"""
Vulnerability Monitor - Monitor for new vulnerabilities in MCP servers
"""
import argparse
import json
import logging
import os
import sys
from datetime import datetime, timezone
from typing import Dict, List, Optional

import requests
from github import Github

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class VulnerabilityMonitor:
    """Monitor for new vulnerabilities in MCP servers"""
    
    def __init__(self, github_token: str):
        self.github = Github(github_token)
        self.github_token = github_token
        
    def get_repo_from_url(self, repo_url: str) -> Optional[str]:
        """Extract owner/repo from GitHub URL"""
        try:
            if 'github.com' not in repo_url:
                return None
                
            parts = repo_url.replace('https://github.com/', '').replace('.git', '').split('/')
            if len(parts) < 2:
                return None
                
            return f"{parts[0]}/{parts[1]}"
        except Exception:
            return None
    
    def check_github_advisories(self, repo_url: str) -> List[Dict]:
        """Check GitHub Security Advisories for a repository"""
        vulnerabilities = []
        
        repo_path = self.get_repo_from_url(repo_url)
        if not repo_path:
            return vulnerabilities
            
        try:
            # Use GitHub GraphQL API to get security advisories
            headers = {
                'Authorization': f'token {self.github_token}',
                'Accept': 'application/vnd.github.v3+json'
            }
            
            # Get repository vulnerabilities via GitHub API
            url = f"https://api.github.com/repos/{repo_path}/vulnerability-alerts"
            response = requests.get(url, headers=headers)
            
            if response.status_code == 200:
                alerts = response.json()
                for alert in alerts:
                    vulnerabilities.append({
                        'source': 'github_advisory',
                        'id': alert.get('id', 'unknown'),
                        'severity': alert.get('severity', 'unknown'),
                        'description': alert.get('description', ''),
                        'published_at': alert.get('published_at', ''),
                        'references': alert.get('references', [])
                    })
            
        except Exception as e:
            logger.warning(f"Error checking GitHub advisories for {repo_path}: {e}")
        
        return vulnerabilities
    
    def check_npm_vulnerabilities(self, repo_url: str) -> List[Dict]:
        """Check for npm vulnerabilities using npm audit API"""
        vulnerabilities = []
        
        try:
            # This would require downloading the repo and running npm audit
            # For now, we'll use a placeholder implementation
            logger.info(f"NPM vulnerability check for {repo_url} - not implemented")
            
        except Exception as e:
            logger.warning(f"Error checking NPM vulnerabilities for {repo_url}: {e}")
        
        return vulnerabilities
    
    def check_python_vulnerabilities(self, repo_url: str) -> List[Dict]:
        """Check for Python vulnerabilities using Safety DB"""
        vulnerabilities = []
        
        try:
            # This would require downloading the repo and running safety check
            # For now, we'll use a placeholder implementation
            logger.info(f"Python vulnerability check for {repo_url} - not implemented")
            
        except Exception as e:
            logger.warning(f"Error checking Python vulnerabilities for {repo_url}: {e}")
        
        return vulnerabilities
    
    def check_cve_databases(self, server_name: str) -> List[Dict]:
        """Check CVE databases for mentions of the server"""
        vulnerabilities = []
        
        try:
            # This would query CVE databases
            # For now, we'll use a placeholder implementation
            logger.info(f"CVE database check for {server_name} - not implemented")
            
        except Exception as e:
            logger.warning(f"Error checking CVE databases for {server_name}: {e}")
        
        return vulnerabilities
    
    def get_last_scan_date(self, server: Dict) -> Optional[datetime]:
        """Get the last vulnerability scan date for a server"""
        try:
            if not server.get('versions'):
                return None
                
            latest_version = server['versions'][0]
            scan_data = latest_version.get('security_scan', {})
            
            if scan_data.get('scan_date'):
                return datetime.fromisoformat(scan_data['scan_date'].replace('Z', '+00:00'))
                
        except Exception as e:
            logger.warning(f"Error getting last scan date for {server.get('name', 'unknown')}: {e}")
        
        return None
    
    def monitor_vulnerabilities(self, servers_data: Dict) -> List[Dict]:
        """Monitor all servers for new vulnerabilities"""
        new_vulnerabilities = []
        
        for server in servers_data.get('servers', []):
            logger.info(f"Checking vulnerabilities for {server['name']}")
            
            # Get last scan date
            last_scan = self.get_last_scan_date(server)
            
            # Check different vulnerability sources
            server_vulns = []
            
            # GitHub Security Advisories
            github_vulns = self.check_github_advisories(server['repository'])
            server_vulns.extend(github_vulns)
            
            # Language-specific checks
            if 'typescript' in server.get('language', '').lower() or 'javascript' in server.get('language', '').lower():
                npm_vulns = self.check_npm_vulnerabilities(server['repository'])
                server_vulns.extend(npm_vulns)
            
            if 'python' in server.get('language', '').lower():
                python_vulns = self.check_python_vulnerabilities(server['repository'])
                server_vulns.extend(python_vulns)
            
            # CVE database checks
            cve_vulns = self.check_cve_databases(server['name'])
            server_vulns.extend(cve_vulns)
            
            # Filter for new vulnerabilities (published after last scan)
            for vuln in server_vulns:
                vuln_date = None
                if vuln.get('published_at'):
                    try:
                        vuln_date = datetime.fromisoformat(vuln['published_at'].replace('Z', '+00:00'))
                    except Exception:
                        pass
                
                # Include if no last scan date or vulnerability is newer
                if not last_scan or not vuln_date or vuln_date > last_scan:
                    new_vulnerabilities.append({
                        'server': server['name'],
                        'slug': server['slug'],
                        'repository': server['repository'],
                        'version': server['versions'][0]['version'] if server.get('versions') else 'unknown',
                        'vulnerability': vuln,
                        'detected_at': datetime.now(timezone.utc).isoformat()
                    })
        
        return new_vulnerabilities
    
    def save_vulnerabilities(self, vulnerabilities: List[Dict], output_file: str):
        """Save vulnerabilities to output file"""
        if vulnerabilities:
            with open(output_file, 'w') as f:
                json.dump(vulnerabilities, f, indent=2)
            logger.info(f"Saved {len(vulnerabilities)} new vulnerabilities to {output_file}")
        else:
            logger.info("No new vulnerabilities found")


def main():
    parser = argparse.ArgumentParser(description='Monitor MCP servers for new vulnerabilities')
    parser.add_argument('--servers', required=True, help='Path to servers.json file')
    parser.add_argument('--output', required=True, help='Output file for new vulnerabilities')
    
    args = parser.parse_args()
    
    # Get GitHub token
    github_token = os.getenv('GITHUB_TOKEN')
    if not github_token:
        logger.error("GITHUB_TOKEN environment variable is required")
        sys.exit(1)
    
    # Load servers data
    try:
        with open(args.servers, 'r') as f:
            servers_data = json.load(f)
    except Exception as e:
        logger.error(f"Error loading servers data: {e}")
        sys.exit(1)
    
    # Initialize monitor
    monitor = VulnerabilityMonitor(github_token)
    
    # Monitor for vulnerabilities
    new_vulnerabilities = monitor.monitor_vulnerabilities(servers_data)
    
    # Save results
    monitor.save_vulnerabilities(new_vulnerabilities, args.output)
    
    logger.info(f"Vulnerability monitoring complete. Found {len(new_vulnerabilities)} new vulnerabilities.")


if __name__ == '__main__':
    main()